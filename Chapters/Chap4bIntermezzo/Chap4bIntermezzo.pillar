!! Lesson 3b – A design intermezzo

In this chapter we revisit previous code to make it nicer and more object-oriented. We will revisit the ==Blinker== class you previously defined.

!!!Developing a nicer LED blinker

Here is a little code snippet showing the API that we want to have. 

[[[
| blinker |
blinker := Blinker new.
blinker delay: 1 second.
blinker start. 
blinker stop. 
]]]

Here is a short explanation of this code:

- In the first line, we declare the variable ==blinker==. We can use any name. We will use this variable to refer to  an instance of the Blinker class;
- In the second line, we instantiate the Blinker class (with uppercase B) and assign the created instance to the ==blinker== variable. In this lesson, we will create this class and methods to control the LED;
- In the third line, we send some messages to the ==blinker== object, for how long and how many times per second. This will make the GPIO behave according to the parameters sent.

Now we will develop all the mandatory class and methods to support this scenario.

Our implementation is a bit biased because we will not define a potentially infinite loop.
We will start with a version that only blink a limited amount of time to get started.

!!! Blinker class definition
We start by defining a class named ==Blinker==. This class has four instance variables ==process==, ==behavior==, ==delay== and ==pin==.

- ==delay== will refer to the delay between two blinks.
- ==pin== will be the pin controlling the led.
- ==behavior== will be a block representing the body of the blinker. 
- ==process== will be a process based on the behavior. This process will be started and stopped by the user.
 
[[[
Object subclass: #Blinker
	instanceVariableNames: 'process delay pin body'
	classVariableNames: ''
	package: 'Blinker'
]]]

We define the method ==delay:== as follows: 

[[[
Blinker >> delay: aDelay
	delay := aDelay
]]]


!!! A first instance initialization

By default we decide to have a delay of 1 second. 
By initializing correctly the instance we will have a more robust code and avoid to force the developer to send the message ==delay:==.

[[[
Blinker >> initialize 
	delay := 1 second.
]]]

Then we initialize a pin to be a digital pin. 

[[[
Blinker >> initialize 
	delay := 1 second.
	pin := PotGPIO id: 4.
	pin board: RpiBoard3B current; beDigitalOutput.
]]]

Here we refer directly to the board and for a pro version of the code we would make sure that the board is just an extra instance variables so that we avoid to have a reference to a kind of global variable. 

!!! Defining the Blinker body

We define a method that will define the blinking behavior. 
The following method, named ==blinkerBody==, is just a loop that is waiting for the delay and toggle the status of the pin.
Hence programming the blinking behavior of our little object.
[[[
Blinker >> blinkerBody

	10 timesRepeat: [ 
		delay wait.
		pin toggleDigitalValue ]
]]]


!!! Revisit the initialization
We revisit the initialization to create a block closure that we will be used to fork a process that will call the blinkerBody method.
We store it into 

[[[
Blinker >> initialize 
	
	delay := 1 second.
	pin := PotGPIO id: 4.
	pin board: RpiBoard3B current; beDigitalOutput.
	body := [ self blinkerBody ].
]]]


!!! Start / stopping
The ==start== method fork a process and store it in the instance variable ==process==.

[[[
Blinker >> start
	process := body forkNamed: 'Blinker'
]]]

The method ==stop== will just simply kills the process. 

[[[
Blinker >> stop 
	process terminate.
	process := nil
]]]


!!!Save your work

Don't forget to save your work remotely. To do this, run this command on your local playground:

[[[
remotePharo saveImage.
]]]

This expression will save the complete Pharo environment running on your remote system.
If your raspberry crashes you will get exactly the same environment that from the moment you saved it. 

!!! Get your code from Rasp to your Pharo

Having all the code only on your rapsberry is definitively naive and not really efficient if you want to version it and avoid to have to do all the manipulation via the remote connection. 

PharoThings can also get your changes from the Raspberry and load them in the Pharo running on your machine. 

[[[
remotePharo applyChangesToClient
]]]

This way you can package your code and publish it on github or other versionning system.

!!! Another use case
We proposed one way to model the blinker.
There are several possible alternatives.
We could just use a loop that is stopped only using the message ==stop==. 
Change the proposed code to introduce this.

!!!Conclusion

In subsequent chapter you will learn how to write a breathing led. 
We suggest that once you have it running, you revisit it using the same approach that the one proposed in this chapter.
